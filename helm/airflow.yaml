airflow:
  image:
    ##
    ## docker-airflow image
    repository: joaopmarques66/airflow
    ##
    ## image tag
    tag: 1.2
    ##
    ## Image pull policy
    ## values: Always or IfNotPresent
    pullPolicy: IfNotPresent
  executor: Kubernetes
  service:
    type: NodePort
  config:
    #AIRFLOW__CORE__SECURE_MODE: "True"
    #AIRFLOW__API__AUTH_BACKEND: "airflow.api.auth.backend.deny_all"
    #AIRFLOW__WEBSERVER__EXPOSE_CONFIG: "False"
    #AIRFLOW__WEBSERVER__RBAC: "False"

    ## DAGS
    AIRFLOW__CORE__EXECUTOR: KubernetesExecutor

    AIRFLOW__SCHEDULER__DAG_DIR_LIST_INTERVAL: "30"
    AIRFLOW__CORE__LOAD_EXAMPLES: "False"

    ## Email (SMTP)
    AIRFLOW__EMAIL__EMAIL_BACKEND: "airflow.utils.email.send_email_smtp"
    AIRFLOW__SMTP__SMTP_HOST: "smtpmail.example.com"
    AIRFLOW__SMTP__SMTP_STARTTLS: "False"
    AIRFLOW__SMTP__SMTP_SSL: "False"
    AIRFLOW__SMTP__SMTP_PORT: "25"
    AIRFLOW__KUBERNETES__KUBE_CLIENT_REQUEST_ARGS: '{\"_request_timeout\":[50, 50]}'
    AIRFLOW__KUBERNETES__NAMESPACE: test-airflow


    AIRFLOW__KUBERNETES__GIT_REPO: https://github.com/jpmarques66/test-airflow-DAG.git
    AIRFLOW__KUBERNETES__GIT_BRANCH: master
    AIRFLOW__KUBERNETES__GIT_DAGS_FOLDER_MOUNT_POINT: /usr/local/airflow/dags


    #AIRFLOW__SMTP__SMTP_MAIL_FROM: "admin@example.com"
    AIRFLOW__KUBERNETES__WORKER_CONTAINER_REPOSITORY: python
    AIRFLOW__KUBERNETES__WORKER_CONTAINER_TAG: 3.6
    AIRFLOW__KUBERNETES__DELETE_WORKER_PODS: False
    AIRFLOW__KUBERNETES__DELETE_WORKER_PODS_ON_FAILURE: False
    AIRFLOW__KUBERNETES__WORKER_CONTAINER_IMAGE_PULL_POLICY: IfNotPresent

  #  AIRFLOW__KUBERNETES__WORKER_SERVICE_ACCOUNT_NAME: airflow
    AIRFLOW__KUBERNETES__DAGS_VOLUME_CLAIM: airflow
    AIRFLOW__KUBERNETES__LOGS_VOLUME_CLAIM: airflow-logs
    AIRFLOW__CORE__DAGS_ARE_PAUSED_AT_CREATION: False
    AIRFLOW__SCHEDULER__CATCHUP_BY_DEFAULT: False

  #  AIRFLOW__KUBERNETES__NAMESPACE: airflow

  #  AIRFLOW__CORE__SQL_ALCHEMY_CONN: postgresql+psycopg2://postgres:airflow@airflow-postgresql:5432/airflow

logsPersistence:
  enabled: true
  existingClaim: ''
  accessMode: ReadWriteOnce
  size: 1Gi

dags:
  ##
  ## mount path for persistent volume.
  ## Note that this location is referred to in airflow.cfg, so if you change it, you must update airflow.cfg accordingly.
  path: /usr/local/airflow/dags
  git:
    url: https://github.com/jpmarques66/test-airflow-DAG.git
    ref: master
    #secret: airflow-git-keys
    #kubectl create secret generic airflow-git-keys \
    #  --from-file=id_rsa=~/.ssh/id_rsa \
    #  --from-file=id_rsa.pub=~/.ssh/id_rsa.pub \
    #  --from-file=known_hosts=~/.ssh/known_hosts

    #privateKeyName: id_rsa

    gitSync:
      ## Turns on the side car container
      enabled: true
      image:
        repository: alpine/git
        tag: latest
        pullPolicy: IfNotPresent
      refreshTime: 60

  initContainer:
    ## Fetch the source code when the pods starts
    enabled: false
    ## Image for the init container (any image with git will do)
    image:
      ## docker-airflow image
      repository: alpine/git
      ## image tag
      tag: 1.0.12
      ## Image pull policy
      ## values: Always or IfNotPresent
      pullPolicy: IfNotPresent
    ## install requirements.txt dependencies automatically
    installRequirements: true
    ## Path to mount dags-data volume to
    mountPath: /dags
    ## Path to add to `mountPath` where we clone/sync git to. Include leading /
    ## example: "/subdirWithDags"
    syncSubPath: ""
    ## Custom resource configuration
    resources: {}


##
## Storage configuration for DAGs
persistence:
  ##
  ## enable persistance storage
  enabled: true
  ##
  ## Existing claim to use
  # existingClaim: nil
  ## Existing claim's subPath to use, e.g. "dags" (optional)
  # subPath: ""
  ##
  ## Persistent Volume Storage Class
  ## If defined, storageClassName: <storageClass>
  ## If set to "-", storageClassName: "", which disables dynamic provisioning
  ## If undefined (the default) or set to null, no storageClassName spec is
  ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
  ##   GKE, AWS & OpenStack)
  # storageClass: default
  accessMode: ReadWriteOnce
  ##
  ## Persistant storage size request
  size: 1Gi


web:
  ## Enable DAG serialization and do not add git-sync containers to web pods. Completely supported in Airflow >= 1.10.10
  serializeDAGs: false
  ##
  ## Set AIRFLOW__WEBSERVER__BASE_URL
  ## Path should match Ingress configuration
  baseUrl: "http://localhost:8080"
  resources: {}
    # limits:
    #   cpu: "300m"
    #   memory: "1Gi"
    # requests:
    #   cpu: "100m"
    #   memory: "512Mi"
  ##
  ## Labels for the web deployment
  labels: {}
  ##
  ## Pod Labels for the web deployment
  podLabels: {}
  ##
  ## Annotations for the web deployment
  annotations: {}
  ##
  ## Pod Annotations for the web deployment
  podAnnotations: {}
  ##
  initialStartupDelay: "60"
  initialDelaySeconds: "360"
  minReadySeconds: 120
  readinessProbe:
    scheme: HTTP
    periodSeconds: 60
    timeoutSeconds: 1
    successThreshold: 1
    failureThreshold: 5
  livenessProbe:
    scheme: HTTP
    periodSeconds: 60
    timeoutSeconds: 1
    successThreshold: 1
    failureThreshold: 5


  ## Support Node, affinity and tolerations for web pod assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#taints-and-tolerations-beta-feature
  nodeSelector: {}
  affinity: {}
  tolerations: []
  ##
  ## Directory in which to mount secrets on webserver nodes.
  secretsDir: /var/airflow/secrets
  ##
  ## Secrets which will be mounted as a file at `secretsDir/<secret name>`.
  secrets: []


##
## Ingress configuration
ingress:
  ##
  ## enable ingress
  ## Note: If you want to change url prefix for web ui or flower even if you do not use ingress,
  ## you can change web.baseUrl and flower.urlPrefix
  enabled: true
  ##
  ## Configure the Ingress webserver endpoint
  web:
    ## NOTE: This requires an airflow version > 1.9.x
    ## For the moment (March 2018) this is **not** available on official package, you will have
    ## to use an image where airflow has been updated to its current HEAD.
    ## You can use the following one:
    ##  stibbons31/docker-airflow-dev:2.0dev
    ##
    ## if path is '/airflow':
    ##  - UI will be accessible at 'http://mycompany.com/airflow/admin'
    ##  - Healthcheck is at 'http://mycompany.com/airflow/health'
    ##  - api is at 'http://mycompany.com/airflow/api'
    ## NOTE: do NOT keep trailing slash. For root configuration, set and empty string
    path: "/airflow"
    ##
    ## Ingress hostname for the webserver
    host: "localhost"
    ##
    ## Annotations for the webserver
    ## Airflow webserver handles relative path completely, just let your load balancer give the HTTP
    ## header like the requested URL (no special configuration neeed)
    annotations: {}
      ##
      ## Example for Traefik:
      # traefik.frontend.rule.type: PathPrefix
      # kubernetes.io/ingress.class: traefik
    ##
    ## Configure the web liveness path.
    ## Defaults to the templated value `{{ ingress.web.path }}/health`
    livenessPath:
    tls:
      ## Set to "true" to enable TLS termination at the ingress
      enabled: false
      ## If enabled, set "secretName" to the secret containing the TLS private key and certificate
      ## Example:
      ## secretName: example-com-crt
    precedingPaths:
      ## Different http paths to add to the ingress before the default path
      ## Example:
      ## - path: "/*"
      ##   serviceName: "ssl-redirect"
      ##   servicePort: "use-annotation"
    succeedingPaths:
      ## Different http paths to add to the ingress after the default path
      ## Example:
      ## - path: "/*"
      ##   serviceName: "ssl-redirect"
      ##   servicePort: "use-annotation"

  ##
  ## Configure the flower Ingress endpoint
  flower:
    ##
    ## If flower is '/airflow/flower':
    ##  - Flower UI is at 'http://mycompany.com/airflow/flower'
    ## NOTE: you need to have a reverse proxy/load balancer able to do URL rewrite in order to have
    ## flower mounted on other path than root. Flower only does half the job in url prefixing: it
    ## only generates the right URL/relative paths in the **returned HTML files**, but expects the
    ## request to have been be at the root.
    ## That's why we need a reverse proxy/load balancer that is able to strip the path
    ## NOTE: do NOT keep trailing slash. For root configuration, set and empty string
    path: "/airflow/flower"
    ##
    ## Configure the liveness path. Keep to "/" for Flower >= jan 2018.
    ## For previous version, enter the same path than in the 'path' key
    ## NOTE: keep the trailing slash.
    livenessPath: /
    ##
    ## hostname for flower
    host: "localhost"
    ##
    ## Annotation for the Flower endpoint
    ##
    ## ==== SKIP THE FOLLOWING BLOCK IF YOU HAVE FLOWER > JANUARY 2018 =============================
    ## Please note their is a small difference between the way Airflow Web server and Flower handles
    ## URL prefixes in HTTP requests:
    ## Flower wants HTTP header to behave like there was no URL prefix, and but still generates
    ## the right URL in html pages thanks to its `--url-prefix` parameter
    ##
    ##    Extracted from the Flower documentation:
    ##    (https://github.com/mher/flower/blob/master/docs/config.rst#url_prefix)
    ##
    ##        To access Flower on http://example.com/flower run it with:
    ##            flower --url-prefix=/flower
    ##
    ##        Use the following nginx configuration:
    ##            server {
    ##              listen 80;
    ##              server_name example.com;
    ##
    ##              location /flower/ {
    ##                rewrite ^/flower/(.*)$ /$1 break;
    ##                proxy_pass http://example.com:5555;
    ##                proxy_set_header Host $host;
    ##              }
    ##            }
    ## ==== IF YOU HAVE FLOWER > JANUARY 2018, NO MORE NEED TO STRIP THE PREFIX ====================
    annotations: {}
      ##
      ## NOTE: it is important here to have your reverse proxy strip the path/rewrite the URL
      ## Example for Traefik:
      # traefik.frontend.rule.type: PathPrefix       ## Flower >= Jan 2018
      # traefik.frontend.rule.type: PathPrefixStrip  ## Flower < Jan 2018
      # kubernetes.io/ingress.class: traefik
    tls:
      ## Set to "true" to enable TLS termination at the ingress
      enabled: false
      ## If enabled, set "secretName" to the secret containing the TLS private key and certificate
      ## Example:
      ## secretName: example-com-crt


workers:
  enabled: false

postgresql:
  enabled: true

redis:
  enabled: false